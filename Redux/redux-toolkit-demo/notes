What is Redux Toolkit

Redux Toolkit is a set of utilities and conventions that simplify the process of managing state in a Redux-based application. It provides several tools to help developers write cleaner, more maintainable code with less boilerplate

Why Redux Toolkit?

1. Boilerplate Reduction:

Problem: Traditional Redux setups require a significant amount of boilerplate code to define actions, action creators, reducers, and store setup.

Solution: Redux Toolkit provides utilities like createSlice and configureStore to minimize boilerplate and make the code more concise.

2. Simplified State Management:

Problem: Managing the state in Redux involves defining actions, action types, and reducers, which can be error-prone and complex.

Solution: createSlice in Redux Toolkit combines action creators and reducers into a single slice, simplifying the state management process.

3. Immutable State Updates:

Problem: Immutability is crucial in Redux, but updating nested state can be challenging.

Solution: Redux Toolkit leverages the Immer library, allowing you to write code that looks like it's mutating state directly while ensuring immutability under the hood.

4. Async Logic Simplification:

Problem: Handling asynchronous logic in Redux requires middleware and additional complexity.

Solution: Redux Toolkit includes the createAsyncThunk utility to simplify the process of handling asynchronous actions.

What is a Slice ?

A "slice" in the context of Redux refers to a collection of Redux-related code: specifically, an action creator and a reducer that manage a specific piece of the application state.

Slices are a concept introduced by Redux Toolkit to reduce boilerplate code and simplify the structure of Redux logic.

Redux Toolkit provides a utility function called createSlice to create these slices.

The createSlice function generates both action creators and a reducer based on a provided initial state and a set of reducer functions.

import { createSlice } from '@reduxjs/toolkit';

const mySlice = createSlice({
name: 'sliceName',
initialState: initialStateValue,
reducers: {
// Reducer functions go here
actionName: (state, action) => { /_ reducer logic _/ },
anotherAction: (state, action) => { /_ reducer logic _/ },
},
});

export const { actionName, anotherAction } = mySlice.actions;
export default mySlice.reducer;

In Redux Toolkit, reducers and extraReducers are used to define how the state should change in response to actions.

Reducers:

- Defined as part of the createSlice function.
- Used for synchronous action types.
- Each key in the reducers object corresponds to a specific action type, and the associated value is a reducer function that describes how to update the state when that action is dispatched.

Typically used for handling actions that don't involve asynchronous operations.

extraReducers:

Used to handle actions generated by createAsyncThunk or other asynchronous actions.
Allows you to respond to multiple action types within a single reducer logic.
Typically used for handling actions that involve asynchronous operations, such as fetching data from an API.

builder:

builder is an object provided by the createSlice function from Redux Toolkit. It's used to define reducers in a more concise and readable manner.
It simplifies the process of defining how the state should change in response to different action types.
It provides methods like .addCase, .addMatcher, and others to specify different cases for action types.

.addCase:

.addCase is a method provided by the builder object.
It is used to associate a specific action type with a callback function that describes how the state should be updated when that action type is dispatched.
The method takes three arguments:
The first argument is the action type or action creator to match.
The second argument is a callback function that defines how the state should be updated when the associated action type is dispatched.
The third argument is an optional description for debugging purposes.
Here's an example of using builder and .addCase:

javascript
Copy code
const mySlice = createSlice({
name: 'mySlice',
initialState: /_ ... _/,
reducers: {},
extraReducers: (builder) => {
builder
.addCase(someActionType, (state, action) => {
// Handle state update for someActionType
})
.addCase(anotherActionType, (state, action) => {
// Handle state update for anotherActionType
});
},
});

//Multiple API calls

export const fetchData1 = createAsyncThunk(
'data/fetchData1',
async () => {
const response = await axios.get('https://api.example.com/data1');
return response.data;
}
);

export const fetchData2 = createAsyncThunk(
'data/fetchData2',
async () => {
const response = await axios.get('https://api.example.com/data2');
return response.data;
}
);

const dataSlice = createSlice({
name: 'data',
initialState: {
data1: [],
data2: [],
status1: 'idle',
status2: 'idle',
error1: null,
error2: null,
},
reducers: {},
extraReducers: (builder) => {
builder
.addCase(fetchData1.pending, (state) => {
state.status1 = 'loading';
})
.addCase(fetchData1.fulfilled, (state, action) => {
state.status1 = 'succeeded';
state.data1 = action.payload;
})
.addCase(fetchData1.rejected, (state, action) => {
state.status1 = 'failed';
state.error1 = action.error.message;
});

    builder
      .addCase(fetchData2.pending, (state) => {
        state.status2 = 'loading';
      })
      .addCase(fetchData2.fulfilled, (state, action) => {
        state.status2 = 'succeeded';
        state.data2 = action.payload;
      })
      .addCase(fetchData2.rejected, (state, action) => {
        state.status2 = 'failed';
        state.error2 = action.error.message;
      });

},
});

//Multiple Slice Files (Folder structure)

src/
|-- features/
| |-- feature1/
| | |-- feature1Slice.js
| | |-- feature1Actions.js
| | |-- feature1Selectors.js
| | |-- ...
| |
| |-- feature2/
| | |-- feature2Slice.js
| | |-- feature2Actions.js
| | |-- feature2Selectors.js
| | |-- ...
| |
|-- shared/
| |-- sharedSlice.js
| |-- sharedActions.js
| |-- sharedSelectors.js
| |-- ...
|-- app/
| |-- rootReducer.js
| |-- store.js
|-- ...

src/
|-- shared/
| |-- sharedSlice.js
| |-- sharedActions.js
| |-- sharedSelectors.js
| |-- ...
|-- features/
| |-- feature1/
| | |-- feature1Slice.js
| | |-- feature1Actions.js
| | |-- feature1Selectors.js
| | |-- ...
| |
| |-- feature2/
| | |-- feature2Slice.js
| | |-- feature2Actions.js
| | |-- feature2Selectors.js
| | |-- ...
|-- app/
| |-- rootReducer.js
| |-- store.js
|-- ...

// can we call promise via redux without using thunk ? (Doubt)

export const fetchData = () => ({
type: 'FETCH_DATA',
payload: new Promise((resolve, reject) => {
setTimeout(() => {
const data = /_ fetched data _/;
resolve(data);
}, 1000);
}),
});

const initialState = {
data: null,
loading: false,
};

const reducer = (state = initialState, action) => {
switch (action.type) {
case 'FETCH_DATA':
return {
...state,
loading: true,
};
case 'FETCH_DATA_SUCCESS':
return {
...state,
loading: false,
data: action.payload,
};
case 'FETCH_DATA_ERROR':
return {
...state,
loading: false,
error: action.payload,
};
default:
return state;
}
};

export default reducer;
